# 09 추천시스템
## 1. 개요
### 유형
#### (1) 콘텐츠 기반 필터링 (Content based filtering)
- 
#### (2) 협업 필터링(Collaborative Filtering)
1. 최근접 이웃(Nearest Neighbor) 협업 필터링
   - 아마존의 경우 아직 사용 
   - 메모리 협업 필터링이라고도 함 
   1) 사용자 기반 : 사용자와 비슷한 고객들이 구매한 상품을 추천
   2) 아이템 기반 : 해당 상품을 선택한 다른 고객들이 구매한 상품 추천 (주로 더 정확)
      - 아이템의 속성과 관계 없이, 사용자들이 그 아이템을 평가한 평가척도가 유사 아이템을 추천하는 기준이 된다!
      - Counter Vectorize 후 코사인 유사도를 활용해 행별(해당 영화에 대한 여러 사람들의 평점) 유사도를 측정해 도출 
      - > [공식]
2. 잠재 요인 (Latent Factor) 협업 필터링 
   - 넷플릭스 추천 시스템 경연 대회에서 행렬분해 기법 이용 잠재 요인 협업 필터링 방식이 우승하며 대부분 이걸 사용하기 시작 
   - **행렬분해(Matrix Factorization)** 사용
   - 사용자-아이템 평점 매트릭스 속 숨어있는 잠재 요인 추출해 추천 예측 : 대규모 다차원 행렬을 SVD와 같은 차원 감소 기법으로 분해하는 과정에서 잠재 요인 추출 
   - 사용자-아이템 평점 행렬 -> (사용자-잠재요인 행렬 , 잠재요인-아이템 행렬) 로 분해 후 이 행렬의 내적곱을 통해 예측 평점 도출 
### 행렬분해
- 다차원 매트릭스 --> 저차원 매트릭스로 분해 
- SVD(Singular Vector Decomposition), NMF(Non-Negative Matrix Factorization) 사용
   > **R = P*Q.T**
   > 
   > R : MxN 사용자-아이템 행렬 / P: MxK 사용자-잠재요인 행렬 / Q : NxK 아이템-잠재요인 행렬
- R행렬을 P와 Q로 분해하기 위해 **SGD**(Stochastic Gradient Descent)를 사용한다
  - SVD의 경우, NaN 값이 없는 행렬에만 적용이 가능하기 때문 
#### 확률적 경사 하강법(SGD)을 이용한 행렬 분해
> 예측된 R행렬 값이 실제 R행렬과 최소의 오류를 가지도록 비용 함수 최적화를 통해 P와 Q를 예측하는 방법
- P와 Q를 임의의 값을 가진 행렬로 설정
- P와 Q.T 값을 곱해 예측 R행렬을 계산
- 예측 R 행렬과 실제 R 행렬에 해당하는 오류 값 계산 
- 오류 값을 최소화할 수 있도록 P와 Q행렬 업데이트
- 위 작업 반복하며 근사화
```python
   # 행렬 생성
   import numpy as np
   R = np.array[[4,np.Nan,np.Nan,2,np.Nan],
                  [np.Nan,5,np.Nan,3,1],
                  [np.Nan,np.Nan,3,4,4],
                  [5,2,1,2,np.Nan]]
   num_users, num_items = R.shape # (4,5)
   K = 3 # 잠재요인의 개수 
   # np.random.normal : 정규분포로부터 임의의 샘플 그림
   P = np.random.normal(scale=1./K, size=(num_users,K))
   Q = np.random.normal(scale=1./K, size=(num_items,K))

   # 오차를 가져오는 함수 생성
   from sklearn.metrics import mean_squared_error
   def get_rmsa(R,P,Q,non_zeros): # non_zero는 추후 코드에서 생성
      error = 0
      # 예측 R 생성 (P와 Q의 전치 내적)
      pred_R = np.dot(P,Q.T)

      # 실제 R에서 null이 아닌 값의 위치 인덱스 추출 (예측R과 비교위해)
      x_non_zero_ind = [non_zero[0] for non_zero in non_zeros]
      y_non_zero_ind = [non_zero[1] for non_zero in non_zeros]

```
- np.random.normal : 정규분포로부터 임의의 샘플 그림
  - 파라미터 : loc=평균의 위치, scales=표준편차, size=샘플사이즈, loc와 scales는 float형태로 받음(?)
- np.array는 R[[1,2],[2,3]] 이렇게 다차원 리스트로 인덱싱이 가능하다(?)


## 2. 콘텐츠 기반 필터링 추천 시스템 - 코드
## 3. 최근접 이웃 협업 필터링 - 코드
## 4. 잠재 요인 협업 필터링 - 코드
